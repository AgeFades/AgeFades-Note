[TOC]

# 项目开发规范

## 前言

- 按实际项目经验整理出的一些规范，可能没与什么业界权威的规范文档挂钩
- 后续持续补充

## 禁止循环操作数据库

### 错误示例

- 场景：查用户列表，用户表中有字段 deptId，表示与部门表关联
- 伪代码如下：

```java
for (User user : users) {
  deptService.getById(user.getDeptId);
}
```

- 一页10条，此操作就与数据库发生了10次交互
- 一页100条，此操作就与数据库发生了100次交互
- 数据库瓶颈是怎么来的..

### 正向处理

- 伪代码如下：

```java
List deptIds = users.stream().map(User::getDeptId).collect(Collects.toList())
  
List depts = deptService.lambdaQuery().in(Dept::getId, deptIds).list();

Map deptIdNameMap = depts.stream.collect(Collects.toMap(Dept::getId, Dept::getName));

for (User user : users) {
  String deptName = deptIdNameMap.get(user.getDeptId);
  // 代码中尽量多做数据判断，像这种情况，不要直接抛异常让整个功能不可用
  // log.error 日志输出，配合 sentry 携带关键参数发送报警邮件，由开发进行排查数据
  if (StrUtil.isBlank(deptName)) {
    log.error("错误数据,deptId[{}]没有对应部门数据", user.getDeptId);
  }
  user.setDeptName(deptName);
}
```

## 禁止循环调feign

- 此处错误示例、正向处理 基本同 `禁止循环操作数据库` 
- for 十条数据，走10次feign，就是10次http连接开销，100次.. 1000次？
- 核心思想都是一次加载完数据，在java内存里去处理，减轻对如数据库的访问压力

## 禁止使用import *

[为什么不用import * & idea该怎么做相关配置](https://zhuanlan.zhihu.com/p/481020755)

- 有些人禁用、有些人没有禁用，则会产生大量冲突文件，解决这种冲突烦不胜烦
- 所以这里要统一禁用 import *

## 禁止直接使用未判空的对象方法

### 错误示例

- 场景：根据id查用户，使用用户的名称字段
- 伪代码如下：

```java
User user = userService.getById(userId);
user.getName();
```

- 数据库查出来的对象就一定可靠吗？比如这里 userId 由前端直接传入，传个错误id，就直接抛 NPE 了吗？给到用户体验的就是 500、系统异常。
- 程序不能要求 用户全按绝对正确的流程 使用，程序的健壮性也应该是程序员必须考虑的问题。

### 正向处理

- 伪代码如下：

```java
User user = userService.getById(userId);
// Assert是一个业务断言类，专门用来校验不合规的数据，并给出友好提示（方便快速定位问题，看提示就能get到原因，而不是抛出500，只能到处去翻日志）
Assert.notNull(user, "不存在的用户数据");
user.getName();
```

## 禁止使用Map或JSON作为接口入参、出参

- 使用Map或JSON，灵活性是可能提高了，但别人读代码的成本就是激增
- 尤其在某些公司、老人和新人没有完善交接的时候，可能就很难读懂当时的代码了

## 代码合并问题

- 开发分支、修复bug分支，在完成开发工作后，都必须合并到 开发（联调）环境。
- 举例：
  1. 从线上分支创建一个新分支，解决了线上问题，直接往线上分支合并后，就删除了解决问题的分支。（没有往 开发（联调）分支合代码）
  2. 然后别的开发同事从 线上分支 创建一个新分支，开发新需求后，往 开发（联调）分支合并，可能就会出现一堆文件冲突（跟他开发的可能没有任何关系）
  3. 这会影响别的开发同事的工作进度（需要解决一堆跟自己没有关系的冲突）

## 日志、注释问题

- 不要出现大段大段的代码，没有注释、没有日志的问题
- 代码不仅是给当下的自己读的，也是给别人、给将来的自己读的
- 养成看日志定位问题的习惯，而不是靠debug（debug多慢？）

## 枚举字段问题

- 举例，用户的证件类型字段
  1. 一定要建立枚举类（code、desc类型的枚举）
  2. 该实体该字段上的注释，一定要标注 取值范围和含义 对应的枚举类
  3. 对该值的 set 赋值操作、比较操作，都要关联它的枚举类，而不是魔法值
- 核心意义就是：让别人能特别快速的 get 到这个字段的 取值范围和含义
- 不推荐使用字典表（没必要为极小概率修改的东西、做大量的辅助工作）
  - 比如：存在字典表里，可以随时修改，而不用修改代码并部署
    - 假设，一年改了 12 次，省了 12 次改代码部署的时间
    - （不加缓存的前提下）每天都查了 1w 次，一年就是多了 365w 次的查询
    - （不以代码中枚举值为准）其他人想 get 到该字段的 取值范围和含义，时间成本大大增加
  - 确有经常改动的 字段项，建议提出放在动态配置文件里。

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1651028783249.png)

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1651028880822.png)

- 建议 code 使用 描述的对应单词 或 单词简写
  - 使用 int（如1,2,3）可以减少存储成本
  - 使用 单词 则可以减少 解释成本、检索成本
    - 查数据库时，比如用户证件类型，值为 1（1能确定是什么含义吗？能拿去项目代码里搜吗？）
    - 而值为 idCard 时，应该能很快得出，这表示 身份证，用 idCard 去项目里检索时，也能比较快的定位。
  - 个人认为，目前硬件资源应该是相对廉价的，能更快更好的 get 相关信息，会比较重要。

## 缓存问题

- 前提：现在项目基本都是使用 Redis 作为缓存层使用，这里也讲的是 Redis 一些事项

- 缓存 key 的前缀要作为 常量 放在 常量类 中，具体使用时，使用前缀 + 关键参数作为最终的 key

  - 举例：

```java
public interface RedisConstant {
  	/**
     * 系统用户信息前缀
     */
    String SYS_USER_INFO_PREFIX = "sys:user:info:";
}

// 使用
String hashKey = RedisConstant.SYS_USER_INFO_PREFIX + userId;
```

- 这是为了方便在 redis 中快速定位自己关心的缓存数据
- 不推荐使用 SpringCache 全局或注解添加缓存（会造成很多实时性问题）
  - 一般来说，我们做的项目都是 实时性项目（第一时间看到最新数据）
  - 不应该加很多缓存去缓解接口响应时间压力，而应该从根本上定位、解决响应慢的接口（如果确实业务特别复杂、没法优化，可与业务方沟通改为异步处理、隔天处理...）

## 统一变量命名字典

- 项目中应有一个 变量统一命名字典 的文档
- 举例：车可以翻译成 car、vehicle，项目中应该统一规定该语义的字段变量命名为 car 或者 vehicle（而不是你起一个名、我起一个名）

## 统一布尔枚举字典

- 绝大部分人开发都是使用 1:是、0:否
  - 但也有些人使用 1:否、0:是
  - 所以项目中应该在公共地方，建立一个统一使用的枚举，大家在用这种 int 表示布尔的时候，都应遵循该枚举

## 逻辑删除问题

- 不建议所有对象都添加逻辑删除字段
  - 除了增加垃圾数据、冗余数据、提高存储成本外，基本不见得有什么逻辑删除完了还要恢复的数据
- 业务有类似需要的时候，应单独针对表进行设计

