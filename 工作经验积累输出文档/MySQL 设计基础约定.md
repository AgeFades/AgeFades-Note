# 数据库表设计规范

## 基础规范

1. 使用 InnoDB 存储引擎
2. 禁止使用外键与级联，一切外键概念必须在应用层解决。
3. 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。
5. 数据库字符集使用 utf8mb4，校对字符集使用 utf8mb4_general_ci
6. 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：a.不是频繁修改的字段。b.不是 varchar 超长字段，更不能是 text 字段。
7. 小数类型使用 decimal，禁止使用 float 和 double。
8. 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。
9. 尽可能不使用 TEXT、BLOB 类型（该数据类型不能设置默认值、不便于排序、不便于建立索引）
10. 同一意义的字段设计定义必须相同（便于联表查询）
12. 库名、表名、字段名使用小写字母，禁止超过 32 个字符，须见名知意
13. 表名不使用复数名词。
14. 表的命名最好是加上“业务名称_表的作用”。例如 sys_dictionary / trade_config
15. 表必须有注释，字段必须有注释。
16. 表达是与否概念的字段，必须使用 is_xxx 的方式命名，不建议使用阿拉伯数字，比如: 是否逻辑删除的字段名为 is_deleted
18. 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。

## 索引设计规范

1. 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
2. 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。
3. 建组合索引的时候，区分度最高的在最左边。
4. 单表索引数量不超过10个
5. 单个字段不要超过两个索引
6. 新建的唯一索引必须不能和主键重复
7. 尽量不要在频繁更新的列上建立索引
8. 不在低基数列上建立索引，例如状态、类型等
9. 不在索引列进行数学运算和函数运算（参与了运算的列不会引用索引）
10. 非唯一索引以 “idx_字段1_字段2” 命名，唯一索引必须以 “uk_字段1_字段2” 命名，更多参考约定前缀

## 约定前缀

1. 主键约束 pk_
2. 普通索引 idx_
3. 唯一约束 uk_

## 查询规范

1. 防止因字段类型不同造成的隐式转换，导致索引失效。
2. SQL 语句尽可能简单，大的 SQL 想办法拆分成小的 SQL 实现
3. 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。
4. 除非必要，避免使用 != 等非等值操作符（会导致用不到索引）
5. WHERE 条件里不要对列使用函数（不会引用索引）
6. 能确定返回结果只有一条时，使用 LIMIT 1（LIMIT 分页注意效率，LIMIT 越大，效率越低）
7. 少用子查询，改用 JOIN（子查询要在内存里建临时表）
8. 多表 JOIN 的字段，区分度最大的字段放在前面
9. 事务要尽量简单，整个事务的时间长度不要太长
10. 页面搜索严禁左模糊或者全模糊，如果和产品设计有冲突，需和产品沟通解决
11. 不要使用 COUNT(列名) 或 COUNT(常量) 来替代 COUNT()， COUNT() 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
12. 在代码中写分页查询逻辑时，若 COUNT 为 0 应直接返回，避免执行后面的分页语句。
13. 不要写一个大而全的数据更新接口。执行 SQL 时，不要更新无改动的字段，一是易出错； 二是效率低； 三是增加 BINLOG 存储。
14. 不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。