[TOC]

# 黑马 - RPC通信原理实战

## RPC概述

### 分布式节点通信

#### 跨节点通信方式-非消息通信

##### Socket

> 原生Socket网络编程，使用TCP/IP协议栈收发数据。
>
> 原生Socket API非常底层，要考虑很多细节，如果再加上异步，就太复杂了。

##### RMI

> 远程调用，能让客户端Java像调用本地方法一样，调用服务端Java对象上的方法。
>
> Java语言实现了RPC，EJB时代盛行

##### 标准公有协议

> 利用标准的公有协议进行跨节点服务调用，例如：
>
> http+xml、restful+json、webserivce ..
>
> 支持EE规范的Web容器部署服务，提供Web接口。
>
> RestTemplate、httpClient、feign...

##### RPC

> 远程过程调用，一个计算机通信协议/规范/标准。
>
> A 调 B，像本地。
>
> 是一种Client/Server模式的概念。

### RPC的作用及优势

> 主要功能目标是 `让构建分布式计算（引用）更容易`
>
> 是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议规范。

#### 为什么要用RPC及优势

1. 分布式设计
2. 部署灵活
3. 解耦服务
4. 扩展性强
5. RPC框架一般使用长连接，不必每次通信都要3次握手，减少网络开销
6. RPC框架一般都有注册中心，有丰富的监控管理
7. 发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作
8. 协议私密，安全性较高
9. RPC能做到协议更简单内容更小，效率更高
10. RPC是面向服务的更高级的抽象，支持服务注册发现、负载均衡、超时重试、熔断降级等高级特性。

### RPC架构设计

![1700205948865.png](https://agefades-note.oss-cn-beijing.aliyuncs.com/1700205948865.png)

## RPC框架实现要点

### 注册中心

> 在高可用的生产环境中，服务一般都以集群方式提供服务，集群里面的IP等重要参数信息可能会随时发生变化，
>
> 节点也可能动态扩缩容，客户端需要能够及时感知服务端的变化，获取集群最新服务节点的连接信息，
>
> 而这些变化要求是对调用方应用无感知的。

#### 主流注册中心

> Zookeeper
>
> Consul
>
> Nacos
>
> ...

### 代理技术

> RPC的调用对用户来讲是透明的，内部核心技术采用的就是代理技术，RPC会自动给接口生成一个代理实现
>
> 当在项目中注入接口的时候，运行过程中实际绑定的就是这个接口生成的代理实现。
>
> 在接口方法被调用的时候，实际上是被生成代理类拦截到了，这样在代理中加入其他调用逻辑的处理。

#### JDK动态代理

> 在运行期动态的创建代理类，是通过接口生成代理类的。
>
> 与静态代理相比更加灵活，但是也有一定的限制。
>
> 第一是代理对象必须实现一个接口，否则会报异常。
>
> 第二是性能问题，因为是通过反射来实现调用的，所以比正常直接调用会慢，而且通过生成类文件也会多消耗部分方法区空间，可能引发Full GC。

#### ASM

> 一个Java字节码操控框架。能够以二进制形式修改已有类或者动态生成类。
>
> ASM可以直接生成二进制class文件，也可以在类被加载入JVM之前动态改变类行为。（生成的代码可以覆盖原来的类，也可以是原始类的子类。）
>
> 不过ASM在创建class字节码的过程中，操纵的是底层JVM的汇编指令级别，这要求使用者对class组织结构和JVM汇编指令有一定了解。

#### CGLIB

> 一个基于ASM的字节码生成库。原理是动态生成一个要代理类的子类，子类重新要代理类的所有不是final的方法。
>
> 在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。
>
> 比使用JDK动态代理要快。

#### bytebuddy

> 也是基于ASM API实现的，是一个较高层级的抽象的字节码操作工具，通过使用 Byte Buddy，任何熟悉Java编程语言的人都有望非常容易得进行字节码操作。

#### Javassit

> 使操作Java字节码变得简单，可以用于编辑Java字节码的类库，提供了两种级别的API:
>
> 源码级别和字节码级别。
>
> 源码级别：操作上层Java API
>
> 字节码级别：直接编辑字节码文件
>
> 使用了反射机制，运行比ASM慢。

### 序列化技术

> 在网络传输中，数据必须采用二进制形式，所以在RPC调用过程中，需要采用序列化技术，对出参入参做序列化和反序列化

#### JDK原生序列化

> 1. JDK本身提供，使用比较方便简单
> 2. 不支持跨语言处理，性能相对不是很好，序列化以后产生的数据相对较大

#### JSON

> 轻量级数据交换格式。
>
> 可读性好，方便阅读和调试，多语言支持，序列化以后的字节码文件相对较大，效率相对不高
>
> 但对比XML序列化后的字节流更小，在企业运用普遍，特别是对前端和三方提供API。

#### Hessian2

> 1. Hessian2是一个动态类型，二进制序列化，并且支持跨语言特性的序列化框架。
> 2. Hessian性能上要比JDK、JSON序列化高效很多，并且生成的字节数也更小。有非常好的兼容性和稳定性。
>
> 所以，Hessian更适合作为RPC框架远程通信的序列化协议。

#### Protobuf

> Google推出的开源序列库，是一种轻便、高效的结构化数据存储格式，多语言支持。
>
> 速度快，压缩比高，体积小，序列化后体积相比JSON、Hessian小很多
>
> 消息格式的扩展、升级和兼容性都不错，可以做到向后兼容。

### 网络

#### IO选型

> RPC的调用过程中涉及到网络IO的操作，一般来说，网络IO往往会成为系统的瓶颈所在。
>
> 而不管上层应用如何使用，底层都是基于 `操作系统的IO模型`

同步阻塞IO

同步非阻塞IO

IO多路复用

信号驱动IO

异步非阻塞IO

#### 线程模型

consumer -> client stub

同步	异步

异步如何实现：

通常使用Future方式，返回Future对象，通过Get方式获取结果

或者采用入参为Callback的回调方式，处理结果

### 超时重试机制

#### 时间轮算法

> 概念：在时间轮机制中，有 `时间槽和时钟轮`的概念，时间槽就相当于时钟的刻度
>
> 时钟轮就相当于指针跳动的一个周期，我们可以将每个任务放到对应的时间槽位上。
>
> 把任务下标先算好，然后放置在该数据结构中，重复就数组 -> 数组+链表，时间跳到这个刻度就只需要检测当前刻度有没有任务即可。

![1700207928086.png](https://agefades-note.oss-cn-beijing.aliyuncs.com/1700207928086.png)

![1700207946568.png](https://agefades-note.oss-cn-beijing.aliyuncs.com/1700207946568.png)

### 负载均衡策略

> RPC Server为了高可用，可选择做集群，因此在RPC Client端调用时要使用相应的均衡策略，这属于客户端负载均衡。
>
> 轮询、随机、权重、最少连接、自适应

### 熔断

> 熔断可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不在访问远程服务器。
>
> 也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试恢复调用操作。
>
> 熔断有时长设置，过了时长后，重新调用远端服务判断是否恢复正常。

### 限流

> 实际生产环境中，每个服务节点都可能由于访问量过大而引起一系列问题，就需要业务提供方能够进行自我保护，
>
> 从而保证在高访问量、高并发的场景下，系统依然能够稳定运行，高效运行。
>
> 限流器的作用是用来限制其请求的速率，保护后台响应服务，以免服务过载导致服务不可用现象出现。

令牌桶、漏桶模型、滑动窗口算法...

![1700209352201.png](https://agefades-note.oss-cn-beijing.aliyuncs.com/1700209352201.png)

![1700209366501.png](https://agefades-note.oss-cn-beijing.aliyuncs.com/1700209366501.png)

#### 令牌桶

假设一个bucket数据结构容器，容量为10，固定速率为里面放token，比如1s产生一个token放进去。

请求进来先从令牌桶拿，拿得到就去请求，拿不到就等着或者被丢弃。

#### 漏桶算法

不管多大流量进来，始终按固定速率出去，比如10s内进了10w个请求，但也只会按1s10个请求发到具体服务端口。

#### 滑动窗口

相比固定窗口，比如1分钟内，最大请求100个：

​	固定窗口是 0-1 1-2，在0.59 - 1 和 1 - 1.01 间，一次进200个请求，这也算满足（实际上连续时间短短0.2s进了200个）

​	滑动窗口是数据进来、出去，窗口跟随滑动的一种思想。比如进来一个数据，窗口往前滑动1s