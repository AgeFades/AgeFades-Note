[TOC]

# 杨过 - 操作系统底层工作的整体认识

## 冯诺依曼计算机模型详解

```shell
# 现代计算机模型是基于 -> 冯诺依曼计算机模型。

# 计算机在运行时，
	# 先按顺序从 内存中 取出指令，通过控制器的 译码，
	
	# 按 指令的要求，从 存储器 中取出数据进行 指定的运算 和 逻辑操作 等加工，
	
	# 然后再按 地址 把结果送到内存中去。
	
# 程序 与 数据 一样存储，按 程序编排 的顺序，一步一步取出指令，
	# 自动完成 指令规定的操作 是计算机最基本的工作模型。
```

### 计算机五大核心组成部分

#### 控制器(Control)

```shell
# 整个计算机的中枢神经，
	# 对 程序规定的控制信息 进行解释，
	
	# 根据其要求进行控制、调度程序、数据、地址，
	
	# 协调 计算机各部分工作及内存与外设的访问 等。
```

#### 运算器(Datapath)

```shell
# 对 数据进行各种算术运算和逻辑运算，
	# 即: 对数据进行加工处理。
```

#### 存储器(Memory)

```shell
# 存储程序、数据和各种信号、命令等信息，
	# 并在需要时提供这些信息。
```

#### 输入(Input system)

```shell
# 输入设备 与 输出设备 合称为 外部设备，简称 外设。

# 输入设备的作用:
	# 将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。
	
# 常见的输入设备有:
	# 键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。
```

#### 输出(Output system)

```shell
# 输出设备的作用:
	# 把 计算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。
	
# 常见的输出设备有:
	# 显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1600137309595.png)

### CPU指令结构

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1600137350642.png)

#### 控制单元

```shell
# 控制单元是整个 CPU 的指挥控制中心。

# 由以下主要组件组成:
	# 指令寄存器
	
	# 指令译码器
	
	# 操作控制器
	
# 根据用户预先编好的程序，依次从存储器中取出各条指令，
	# 放在 指令寄存器 中，通过 指令译码器 分析确定应该进行什么操作，
	
	# 然后通过 操作控制器 按确定的时序，向相应的部件发出 微操作控制信号。
	
# 操作控制器中主要包括:
	# 节拍脉冲发生器
	
	# 控制矩阵
	
	# 时钟脉冲发生器
	
	# 复位电路和启停电路等控制逻辑
```

#### 运算单元

```shell
# 运算单元是运算器的核心。

# 主要执行:
	# 算术运算: 包括加减乘除等基本运算及其附加运算。
	
	# 逻辑预算: 包括移位、逻辑测试或两个值比较。
	
# 相对 控制单元 而言，运算器接受控制单元的命令而进行动作，
	# 即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，
	
	# 所以它是执行部件。
```

#### 存储单元

```shell
# 存储单元包括 CPU片内缓存Cache 和 寄存器组，
	# 是 CPU 中暂时存放数据的地方。
	
# CPU 访问 寄存器 所用的时间要比访问内存的时间短，
	# 因为 寄存器 是 CPU内部的元件，寄存器拥有非常高的读写速度，
	
	# 可以减少 CPU 访问内存的次数，提高 CPU 的工作速度。
	
# 寄存器组可分为 专用寄存器 和 通用寄存器，
	# 专用寄存器的作用是固定的，分别寄存相应的数据，
	
	# 通用寄存器用途广泛并可由程序员规定其用途。
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1600224018976.png)

### CPU缓存结构

```shell
# 现代 CPU 为了提升执行效率，减少 CPU 与 内存 的交互（交互影响 CPU 效率）,
	# 一般在 CPU 上集成了多级缓存架构，
	
	# 常见的为 三级缓存架构。
		# L1 Cache，分为 数据缓存 和 指令缓存，逻辑核独占
		
		# L2 Cache，物理核独占，逻辑核共享
		
		# L3 Cache，所有物理核共享
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1600225755824.png)

```shell
# 存储器存储空间大小:
	# 内存 > L3 > L2 > L1 > 寄存器
	
# 存储器速度快慢排序:
	# 寄存器 > L1 > L2 > L3 > 内存
	
# 值得注意的一点:
	# 缓存 是由最小的存储区块 - 缓存行(cacheline) 组成，
	
	# 缓存行大小通常为 64 byte
	
# 缓存行的意思:
	# 比如 L1 缓存大小 512 kb，
	
	# 而 cacheline 64byte，
	
	# 那 L1 就有 512 * 1024 / 64 个 cacheline
```

#### CPU读取存储器数据过程

```shell
# 1. CPU 要取 寄存器X的值，只需要一步: 直接读取

# 2. CPU 要取 L1 cache 的值，需要 1-3 步(或者更多)
	# 把 cache 行锁住，把某个数据拿来，
	
	# 解锁，如果没锁住就慢了。
	
# 3. CPU 要取 L2 cache 的值，先要到 L1 cache 里取，
	# L1 当中不存在，在 L2 里，
	
	# L2 开始加锁，加锁以后，把 L2 里的数据复制到 L1，
	
	# 再执行读 L1 的过程，上面的 3 步，再解锁。
	
# 4. CPU 取 L3 cache 的也是一样，只不过先由 L3 复制到 L2，从 L2 复制到 L1，从 L1 到 CPU。

# 5. CPU 取内存最复杂
	# 通知 内存控制器 占用总线带宽，
	
	# 通知内存加锁，发起内存读请求，
	
	# 等待回应，回应数据保存到 L3（如果没有就到 L2），
	
	# 再从 L3 -> L2 -> L1 -> CPU，最后解除总线锁定。
```

#### CPU为何要有高速缓存

```shell
# CPU 在摩尔定律的指导下，以每18个月翻一番的速度发展，
	# 然而 内存和硬盘 的发展速度远远不及 CPU，
	
	# 这就造成了 高性能的内存和硬盘价格 极其昂贵，
	
	# 然而 CPU 的高速运算需要高速的数据，为了解决这个问题
		# CPU 厂商在 CPU 中内置了 少量的高速缓存 以解决 I/O速度 和 CPU运算速度 不匹配 的问题。
```

#### 局部性原理

```shell
# 在 CPU 访问存储设备时，
	# 无论是 存取数据 还是 存取指令，
	
	# 都趋于聚集在一片连续的区域中，
	
	# 这被称之为: 局部性原理。
```

##### 时间局部性

```shell
# 如果一个 信息项 正在被访问，
	# 那么在近期它很可能还会被再次访问，
	
	# 比如 循环、递归、方法的反复调用等等..
```

##### 空间局部性

```shell
# 如果一个 存储器 的位置被引用，
	# 那么将来它附近的位置也会被引用，
	
	# 比如顺序执行的代码、连续创建的两个对象、数组等。
```

##### 代码验证

```java
/**
 * 二维数组不同求和、证明 CPU 读主存数据会遵循 空间局部性
 *
 * @author DuChao
 * @date 2020/10/13 10:40 上午
 */
public class TwoDimensionalArraySum {

    public static void main(String[] args) {
        // 数据初始化
        long[][] arrays = new long[1024 * 1024][6];
        for (int i = 0; i < 1024 * 1024; i++) {
            for (int j = 0; j < 6; j++) {
                arrays[i][j] = 1;
            }
        }

        long sum1 = 0L;
        TimeInterval timer1 = DateUtil.timer();
        for (int i = 0; i < 1024 * 1024; i++) {
            for (int j = 0; j < 6; j++) {
                sum1 += arrays[i][j];
            }
        }
        System.out.println("sum1: " + sum1 + ", time1: " + timer1.interval() + "毫秒");

        long sum2 = 0L;
        TimeInterval timer2 = DateUtil.timer();
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 1024 * 1024; j++) {
                sum2 += arrays[j][i];
            }
        }
        System.out.println("sum2: " + sum2 + ", time2: " + timer2.interval() + "毫秒");

    }

}
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602557618651.png)

#### 带有高速缓存的CPU执行计算的流程

```shell
 # 1. 程序以及数据被加载到主内存

# 2. 指令和数据被加载到 CPU 的高速缓存

# 3. CPU 执行指令,把结果写到高速缓存

# 4. 高速缓存中的数据写回到主内存
```

### CPU运行安全等级

```shell
# CPU 有4个运行级别:
	# ring0
	
	# ring1
	
	# ring2
	
	# ring3
	
# Linux 与 Windows 只用到了2个级别，ring0、ring3
	# 操作系统内部程序指令通常运行在 ring0 级别，
	
	# 操作系统以外的第三方程序运行在 ring3 级别，
	
	# 第三方程序如果要调用 操作系统内部函数功能，
		# 由于 运行安全级别不够，必须切换 CPU 运行状态，
		
		# 从 ring3 切换到 ring0，再执行系统函数。
		
		# 这就是 JVM 创建线程、线程 阻塞/唤醒 是重型操作 的原因（因为CPU要切换运行状态）
```

#### JVM 创建线程、CPU 的工作过程

```shell
1. CUP 从 ring3 切换 ring0 创建线程

2. 创建完毕，CPU 从 ring0 切换回 ring3

3. 线程执行 JVM 程序

4. 线程执行完毕，销毁还得切回 ring0
```

## 操作系统内存管理

### 执行空间保护

```shell
# 操作系统有 用户空间 和 内核空间 两个概念，
	# 目的是为了做到 程序运行安全隔离与稳定。
	
# 以 32位操作系统 4G内存空间 为例:
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602571455685.png)

```shell
# Linux 为 内核代码 和 数据结构 预留了几个页框，
	# 这些 页 永远不会被转出到 磁盘 上。
	
# 从 0x00000000 到 0xc0000000（PAGE_OFFSET）的线性地址，
	# 可由 用户代码 和 内核代码 进行引用（即用户空间）
	
# 从 0xc0000000 到 0xFFFFFFFFF 的线性地址，
	# 只能由 内核代码 进行访问（即内核空间）
	
# 内核代码 及其 数据机构 都必须位于这 1GB 地址空间中，
	# 但是对于此地址空间而言，更大的消费者是 物理地址 的 虚拟映射。
```

```shell
# 这意味着，在 4G 内存中，只有 3G 可用于 用户应用程序，
	# 进程 和 线程 只能运行在 用户方式（usermode）或 内核方式（kernelmode）下，
	
	# 用户程序 运行在 用户方式下，而 系统调用 运行在 内核方式下。
	
# 这 两种方式 下所用的 堆栈 不一样，
	# 用户方式: 用 一般的堆栈（用户空间的堆栈）
	
	# 内核方式: 用 固定大小堆栈（内核空间的堆栈，一般为一个 内存页 的大小）
	
# 即: 每个 进程或线程，其实有两个堆栈，
	# 分别 运行于 用户态、内核态。
```

```shell
# 由 空间划分，再 引深一下，CPU 调度的基本单位线程，也 划分为:
	# 内核线程模型（KLT）
	
	# 用户线程模型（ULT）
```

#### 内核线程模型

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602572973787.png)

```shell
# 系统内核管理线程（KLT）:
	# 内核保存线程的状态和上下文信息，
	
	# 线程阻塞不会引起进程阻塞。
	
# 在多处理器系统上，多线程在多处理器上并发运行。

# 线程的创建、调度和管理由内核完成。

# 效率比 ULT 要慢，比进程操作快。
```

#### 用户线程模型

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602573268867.png)

```shell
# 用户线程（ULT）:
	# 用户程序实现，不依赖操作系统核心，应用提供创建、同步、调度和管理线程的函数来控制用户线程，
	
	# 不需要 用户态/内核态 切换，速度快，
	
	# 内核对 ULT 无感知，线程阻塞则进程（包括其所有子线程）阻塞。
```

```shell
# 思考题: JVM 采用哪一种线程模型？
	# KLT(内核线程模型)，因为 JVM 对线程的创建、阻塞、销毁，都是由操作系统完成的。
```

## 进程与线程

### 进程

```shell
# 现代操作系统在运行一个程序时，会为其创建一个进程。

# 例如: 启动一个 Java 程序，操作系统就会创建一个 Java 进程。

# 进程是 OS(操作系统) 资源分配的最小单位。
```

### 线程

```shell
# 线程是 OS(操作系统) 调度CPU 的最小单元，
	# 也叫 轻量级进程（Light Weight Process）
	
# 在一个进程里，可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，
	# 并且能够访问 共享的内存变量。
	
# CPU 在这些线程上 高速切换，让使用者感觉这些线程在同时执行，
	# 即 并发的概念，相似的概念还有 并行！
```

### 线程上下文切换过程

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602574554800.png)

## 虚拟机指令集架构

```shell
# 虚拟机指令集架构主要分两种:
	# 栈指令集架构
	
	# 寄存器指令集架构
	
# 关于 指令集架构的 wiki详细说明
https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B
```

### 栈指令集架构

```shell
# 设计和实现更简单，适用于资源受限的系统

# 避开了 寄存器 的分配难题，使用 零地址指令方式 分配

# 指令流中的指令大部分是 零地址指令，
	# 其执行过程依赖于 操作栈，
	
	# 指令集更小，编译器容易实现
	
# 不需要硬件支持，可移植性更好，更好实现跨平台。

# Java 符合典型的 栈指令集架构特征、Python、Go 都属于这种架构。
```

### 寄存器指令集架构

```shell
# 典型的应用是 x86 的二进制指令集，
	# 比如: 传统的PC 以及 Android的Davlik 虚拟机
	
# 指令集架构则完全依赖硬件，可移植性差

# 性能优秀、执行更高效

# 花费更少的指令去完成一项操作

# 在大部分情况下，基于 寄存器架构 的指令集，
	# 往往都以 一地址指令、二地址指令和三地址指令为主，
	
	# 而基于 栈式架构 的指令集 却是以 零地址指令 为主。
```

