[TOC]



# 硅谷 - 数据结构和算法

## 数据结构和算法内容介绍

### 几个经典的算法面试题

```shell
# 字符串匹配问题
	# str1 = "你快乐吗快乐吗快乐你乐吗"， str2 = "快乐你你你乐快吗你快乐吗"
		# 最快的速度匹配，str1 是否包含 str2，如果存在，就返回第一次出现的位置，如果没有，则返回 -1
	
	# 解决思路:
		# 暴力匹配
		# KMP 算法<部分匹配表>
```

```shell
# 汉诺塔游戏
	# 将 A 塔所有圆盘移动到 C 盘，并且小圆盘上不能放大圆盘，三个柱子之间一次只能移动一个圆盘。
```

![UTOOLS1575600574554.png](https://img01.sogoucdn.com/app/a/100520146/cdf9253c3623f8066a48440528a75923)

```shell
# 八皇后问题
	# 回朔算法的典型案例
	# 在 8x8 格的国际象棋上摆放八个皇后，使其不能互相攻击
	# 即: 任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法
```

![UTOOLS1575600691256.png](https://img04.sogoucdn.com/app/a/100520146/d1374e90f3a35baf2d0ed942f2a7461c)

```shell
# 马踏棋盘<骑士周游>
	# 将马随机放在国际象棋的 8x8 棋盘的某个放个中，马走日进行移动，要求每个方格只进入一次，走遍棋盘上全部 64 个方格
	# 图的深度优化遍历算法<DFS> + 贪心算法优化
```

![UTOOLS1575600813113.png](https://img04.sogoucdn.com/app/a/100520146/1c12369b2be1b9b6940a000c70dc8353)

### 数据结构和算法的重要性

```shell
# 算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高度计算。
```

## 数据结构和算法概述

### 数据结构和算法的关系

```shell
# 数据结构是一门研究组织数据方式的学科

# 程序 = 数据结构 + 算法

# 数据结构是算法的基础
```

### 线性结构和非线性结构

```shell
# 数据结构包括:
	# 线性结构和非线性结构
```

#### 线性结构

```shell
# 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。

# 线性结构有两种不同的存储结构，即顺序存储结构<数组> 和链式存储结构<链表>。
	# 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。
	
	# 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。
	
# 常见的线性结构有:
	# 数组、队列、链表和栈。
```

#### 非线性结构

```shell
# 非线性结构包括:
	# 二维数组
	# 多维数组
	# 广义表
	# 树结构
	# 图结构
```

## 稀疏数组和队列

### 稀疏数组

#### 五子棋的问题

```shell
# 编写的五子棋程序中，有存盘退出和续上盘的功能。
```

![UTOOLS1575601280168.png](https://img02.sogoucdn.com/app/a/100520146/6d14f3f9d428798a01297d7913c53f65)

##### 问题分析

```shell
# 因为该二维数组的很多值都是默认值 0，因此记录了很多没有意义的数据 
```

#### 基本介绍

```shell
# 当一个数组中大部分元素为 0，或者为同一个值得数组时，可以使用稀疏数组来保存该数组。

# 稀疏数组的处理方法是:
	# 记录数组一共有几行几列，有多少个不同的值
	# 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小存储数据结构的规模
```

![UTOOLS1575601473254.png](https://img01.sogoucdn.com/app/a/100520146/8cb9d50ec316dd8d6fc6d0f521a89b79)

#### 思路分析

```shell
# 二维数组 转 稀疏数组的思路
	# 遍历原始的二维数组，得到有效数据的个数 sum ->
		# 根据 sum 就可以创建 稀疏数组 sparseArr int[sum+1][3] ->
		# 将二维数组的有效数据存入到稀疏数组
		
# 稀疏数组转原始的二维数组的思路
	# 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
	# 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可
```

#### 代码验证

```java
public class SparseArray {

    public static void main(String[] args) {
        // 创建一个原始的二维数组 11 * 11
        // 0: 表示没有棋子 1: 表示黑子 2: 表示蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[4][5] = 2;

        // 输出原始数组
        Arrays.stream(chessArr1)
                .forEach(ints -> {
                    Arrays.stream(ints).forEach(data -> System.out.printf("%d\t", data));
                    System.out.println();
                });

        // 得到二维数组非 0 个数
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    sum++;
                }
            }
        }

        // 将二维数组 转 稀疏数组
        int sparseArr[][] = new int[sum + 1][3];
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        // 遍历二维数组，将非 0 的值存放到 sparseArr
        int count = 0; // 记录第几个非 0 数据
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }

        System.out.println("----------------------");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }

        System.out.println("----------------------");
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        for (int i = 1; i < sparseArr.length; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        Arrays.stream(chessArr2)
                .forEach(ints -> {
                    Arrays.stream(ints).forEach(data -> System.out.printf("%d\t", data));
                    System.out.println();
                });

    }

}
```

### 队列

#### 介绍

```shell
# 队列是一个有序列表，可以用 数组 或是 链表来实现

# 遵循 先入先出 的原则。

# 数组模拟队列示意图:
```

![UTOOLS1575610263678.png](https://img03.sogoucdn.com/app/a/100520146/ad34e99ce46f9b61e005e0872f82b7a5)

#### 数组模拟队列思路

```shell
# 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图
	# 其中 maxSize 是该队列的最大容量
	
# 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量
	# front 记录队列前端下标，会随着数据输出而改变
	# rear 记录队列后端的下标，而 rear 则是随着数据输入而改变
```

![UTOOLS1575611292864.png](https://img04.sogoucdn.com/app/a/100520146/be0ad51bf50e681cc155101f33573580)

```shell
# 当我们将数据存入队列时称为 "addQueue"
	# 将尾指针往后移: rear + 1，当 front == rear 【空】
	# 若尾指针 rear 小于队列的最大下标 maxSize-1 ->
		# 则将数据存入 rear 所指的数组元素中，否则无法存入数据 ->
		# rear == maxSize -1 【队列满】
```

```java
public class ArrayQueue {

    // 数组的最大容量
    private int maxSize;

    // 队列头
    private int front;

    // 队列尾
    private int rear;

    // 存放数据，模拟队列容器
    private int[] arr;

    // 创建队列的构造器
    public ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1; // 指向队列头部，分析出 front 是指向队列头的前一个位置
        rear = -1; // 指向队列尾，即队列最后一个数据
    }

    // 判断队列是否满
    public boolean isFull(){
        return rear == maxSize - 1;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("the queue is full");
            return;
        }
        rear ++; // 尾指针后移
        arr[rear] = n;
    }

    // 获取队列的数据
    public int getQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        front ++; // 头指针后移
        return arr[front];
    }

    // 遍历队列
    public void showQueue(){
        if (isEmpty()){
            System.out.println("the queue is empty");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }

    // 显示队列的头数据
    public int headQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        return arr[front + 1];
    }

}
```

#### 问题分析并优化

```shell
# 目前数组使用一次就不能用，没有达到优化的效果

# 将这个数组改进成一个 环形的队列 <取模: %>
```

#### 思路分析

```shell
# 尾索引的下一个为头索引时表示队列满
	# 即将队列容量空出一个作为约定
	# 在做判断队列满的时候需要注意 
		# (rear + 1) % maxSize == front【满】
		# rear == front【空】
		
# 分析示意图:
```

![UTOOLS1575616062211.png](https://img01.sogoucdn.com/app/a/100520146/4a089304087b0e969b7471352245fc28)

##### 思路如下

```shell
# front 变量的含义做一个调整:
	# front 就指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元素，初始值为 0
	
# rear 变量的含义做一个调整:
	# rear 指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定
	# read 的初始值为 0
	
# 当队列满时，条件是(rear + 1) % maxSize = front【满】

# 当队列为空时，rear == front【空】

# 队列中有效的数据个数:
	# (rear + maxSize - front) % maxSize
	# rear = 1，front = 0
	
# 这样在原来的队列上修改得到，一个环形队列
```

```java
public class CircleArray {

    // 数组的最大容量
    private int maxSize;

    // 队列头，初始值为 0
    private int front;

    // 队列尾，初始值为 0
    private int rear;

    // 存放数据，模拟队列容器
    private int[] arr;

    // 创建队列的构造器
    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    // 判断队列是否满
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("the queue is full");
            return;
        }
        // 加入数据
        arr[rear] = n;
        // 移动 rear 指针
        rear = (rear + 1) % maxSize;

    }

    // 获取队列的数据
    public int getQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    // 遍历队列
    public void showQueue(){
        if (isEmpty()){
            System.out.println("the queue is empty");
            return;
        }
        for (int i = front; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    // 显示队列的头数据
    public int headQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        return arr[front % maxSize];
    }

    // 当前队列有效数据的个数
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }

}
```

## 链表

### 介绍

```shell
# 链表是有序的列表，但是它在内存中是存储如下:
```

![UTOOLS1575617283864.png](https://img01.sogoucdn.com/app/a/100520146/e970726ccadf5d64d579da7a3719a2a3)

```shell
# 链表是以节点的方式来存储，是链式存储

# 每个节点包含 data 域，next 域<指向下一个节点>

# 链表的各个节点不一定是连续存储

# 链表分 带头节点的链表 和 没有头节点的链表
```

#### 带头节点逻辑示意图

![UTOOLS1575617501182.png](https://img03.sogoucdn.com/app/a/100520146/4ae1eea1f7e8fba92f736a0ecd2af09b)

### 单链表的应用实例

```java
public class SingleLinkedList {

    // 初始化一个虚拟头结点
    private HeroNode head = new HeroNode(0,"");

    // 不考虑编号顺序，直接添加到单链表的最后节点
    public void add(HeroNode node) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null)
                break;
            temp = temp.next;
        }
        temp.next = node;
    }

    // 根据排名将英雄插入到指定位置，如有这个排名，则添加失败
    public void addByOrder(HeroNode node) {
        HeroNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.next == null)
                break;
            if (temp.next.no > node.no)
                break;
            else if (temp.next.no == node.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            System.out.printf("%d 已存在，不能加入\n", node.no);
        else {
            node.next = temp.next;
            temp.next = node;
        }
    }

    // 根据 no 编号修改节点信息
    public void update(HeroNode node) {
        if (isEmpty())
            throw new RuntimeException("the likedList is empty");
        HeroNode temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp == null)
                break;
            if (temp.no == node.no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            temp.name = node.name;
        else
            throw new RuntimeException("the node was not found");
    }

    // 删除节点
    public void del(int no) {
        HeroNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.next == null)
                break;
            if (temp.next.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            temp.next = temp.next.next;
        else
            throw new RuntimeException("the node was not found");
    }

    // 显示链表
    public void showList(){
        if (isEmpty()n
            throw new RuntimeException("the linkedList is empty");
        HeroNode temp = head.next;
        while(true) {
            if (temp == null)
                break;
            System.out.println(temp);
            temp = temp.next;
        }
    }

    // 判断链表是否为空
    public boolean isEmpty(){
        return head.next == null;
    }

}

class HeroNode {

    public int no;
    public String name;
    public HeroNode next;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 单链表面试题

#### 求单链表中有效节点的个数

```java
/**
 * 获取到单链表的节点的个数<如果是带头结点的链表，需求不统计头节点>
 * @param head : 链表的头结点
 * @return : 返回有效节点的个数
 */
public static int getLength(HeroNode head) {
  	if (head.next == null)
    	return 0;
  
 	  int length = 0;
  	HeroNode cur = head.next;
    while (cur != null) {
      length++;
      cur = cur.next;
    }
  
  	return length;
}
```

#### 查找单链表中的倒数第 k 个节点

```java
/**
 * param : 参数接收 head 节点，同时接收一个 index
 * 思路 : 先从头到尾遍历节点，得到链表的总长度
 *				 size - index 即倒数第 k 个节点
 */
public static HeroNode findLastIndexNode(HeroNode head, int index) {
  	// 判断如果链表为空，返回 null
  	if (isEmpty())
      throw new RuntimeException("the linkedList is empty");
  	// 获取链表长度
  	int size = getLength(head);
  	// index 值校验
    if (index <= 0 || index > size)
      throw new RuntimeException("the index is illegal");
  
  	HeroNode cur = head.next;
   	for (int i = 0; i < size - index; i++) {
      cur = cur.next;
    }
  	return cur;
}
```

#### 单链表的反转

```shell
# 思路:
	# 先定义一个节点 reverseHead
	# 从头到尾遍历链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead 的最前端
	# 原来的链表的 head.next = reverseHead.next
```

```java
public static void reverseList(HeroNode head) {
		// 判断是否需要反转
    if (head.next == null || head.next.next == null) {
      return;
    }
		
    HeroNode cur = head.next;	// 取出当前链表的第一个节点作为初始化当前节点
    HeroNode next = null;
    HeroNode reverseHead = new HeroNode(0, "");	// 定义虚拟链表头辅助变量

    while (cur != null) {	// 遍历条件，原链表的 next 节点不为空时
      next = cur.next;	// 将辅助变量指向当前节点的下一个节点
      cur.next = reverseHead.next;	// 将 reverseHead 头结点的 next 赋值给当前节点的 next
      reverseHead.next = cur;	// 将当前节点赋值给 reverseHead 的 next
      cur = next;	// 后移当前节点的位置
    }

    head.next = reverseHead.next;	// 切换头结点
}
```

#### 从尾到头打印单链表

##### 思路

```shell
# 要求就是逆序打印单链表

# 方法1:
	# 先将单链表进行反转操作，然后再进行遍历即可。
	# 问题: 会破坏原来的单链表结构，不建议
	
# 方法2:
	# 利用 栈 这个数据结构，将各个节点压入到 栈 中
	# 然后利用 栈 的 先进后出 的特点，实现逆序打印的效果
```

```java
public static void reversePrint(HeroNode head) {
  	if (head.next == null) {
      return;
    }
  	Stack<HeroNode> stack = new Stack<>();
  	HeroNode cur = head.next;
  	while (cur != null) {
      stack.push(cur);
      cur = cur.next;
    }
  	while (stack.size() > 0) {
      System.out.println(stack.pop());
    }
}
```

#### 合并两个有序的单链表，合并之后的链表依然有序

```java
@Data
@ToString
class Node {

    int val;
    Node next;

    public Node(int val) {
        this.val = val;
    }

    public static Node mergeTwoLists(Node n1, Node n2){
      	// 判断某个链表是否为空，空值直接返回另一个链表
        if (n1 == null) return n2;
        if (n2 == null) return n1;

        Node head = null;	// 定义新的头节点
        if (n1.val <= n2.val) {	// 默认升序比较
            head = n1;	// 将小值赋值给 head
            head.next = mergeTwoLists(n1.next, n2); // 递归比较，获取下个小值
        } else {
            head = n2;
            head.next = mergeTwoLists(n2.next, n1);
        }
        return head;
    }
}
```

### 双向链表应用实例

```shell
# 管理单向链表的缺点分析:
	# 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
	# 单向链表不能自我删除，需要靠辅助节点。
	# 而双向链表，则可以自我删除。
```

#### 代码实例

```java
public class DoubleLinkedList {

    private Node head = new Node(0, "");

    public Node getHead() {
        return head;
    }

    public void list() {
        if (head.next == null) throw new RuntimeException("the list is empty");

        Node temp = head.next;
        while (true) {
            if (temp == null) break;

            System.out.println(temp);
            temp = temp.next;
        }
    }

    public void add(Node node) {
        Node temp = head;
        while (true) {
            if (temp.next == null) break;
            temp = temp.next;
        }
        temp.next = node;
        node.pre = temp;
    }

    public void update(Node node) {
        if (head.next == null) throw new RuntimeException("the list is empty");

        Node temp = head.next;
        boolean flag = false;

        while (true) {
            if (temp == null) break;
            if (temp.val == node.val) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) temp.name = node.name;
        else throw new RuntimeException("the node was not found");
    }

    public void del(int val) {
        if (head.next == null) throw new RuntimeException("the list is empty");
        Node temp = head.next;
        boolean flag = false;

        while (true) {
            if (temp == null) break;
            if (temp.val == val) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) {
            temp.pre.next = temp.next;
            if (temp.next != null) temp.next.pre = temp.pre;
        } else {
            throw new RuntimeException("the node was not found");
        }
    }

}

class Node {

    public int val;
    public String name;
    public Node pre;
    public Node next;

    public Node(int val, String name) {
        this.val = val;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Node{" +
                "val=" + val +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 单向环形链表应用场景

#### Josephu 问题

```shell
# 约瑟夫问题:
	# 设编号为 1，2,... n 的 n 个人围坐一圈，约定编号为 k（1 <= k <= n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
```

#### 思路分析

```shell
# 用一个不带头节点的循环链表来处理 Josephu 问题

# 先构成一个有 n 个节点的单循环链表，然后由 k 节点起从 1 开始计数
	# 计数到 m 时，对应节点从链表中删除
	# 然后再从被删除节点的下一个节点又从 1 开始计数，直到最后一个节点从链表中删除
	# 算法结束
```

#### 单向环形链表

![UTOOLS1575870350039.png](https://img02.sogoucdn.com/app/a/100520146/72ec8b1cfbd4f05ad2a2ca9ec5f252e4)

#### 代码实现

```java
public class Joseph {

    public static void main(String[] args) {
        CircleSingleLinkedList list = new CircleSingleLinkedList();
        list.add(125);
        list.show();
        list.josephOut(10, 20, 125);
    }

}

class CircleSingleLinkedList {

    private Node first = null;

    public void add(int nums) {
        if (nums < 1) throw new RuntimeException("the parameter is illegal");
        Node cur = null;
        for (int i = 1; i <= nums; i++) {
            Node node = new Node(i);
            if (i == 1) {
                first = node;
                first.next = first;
                cur = first;
            } else {
                cur.next = node;
                node.next = first;
                cur = node;
            }
        }
    }

    public void show() {
        if (first == null) throw new RuntimeException("the list is empty");

        Node temp = first;
        while (true) {
            System.out.printf("节点编号%d\n", temp.no);
            if (temp.next == first) break;
            temp = temp.next;
        }
    }

    /**
     * 约瑟夫问题出圈顺序
     * @param startNo : 表示从第几个节点开始
     * @param countNum : 表示数几个节点
     * @param nums  : 表示最初有多少个节点
     */
    public void josephOut(int startNo, int countNum, int nums) {
        if (first == null || startNo < 1 || startNo > nums)
            throw new RuntimeException("the parameter is illegal");

        Node temp = first;
        while (true) {
            if (temp.next == first) break;
            temp = temp.next;
        }

        for (int j = 0; j < startNo - 1; j++) {
            first = first.next;
            temp = temp.next;
        }

        while (true) {
            if (temp == first) break;
            for (int j = 0; j < countNum -1; j++){
                first = first.next;
                temp = temp.next;
            }
            System.out.printf("Node %d 出圈\n", first.no);
            first = first.next;
            temp.next = first;
        }

        System.out.printf("最后留在圈中的节点编号 %d\n", first.no);
    }

}

class Node {
    public int no;
    public Node next;

    public Node(int no) {
        this.no = no;
    }
}
```

## 栈

### 栈的介绍

```shell
# Stack:
	# 栈是一个 先入后出（FILO - First In Last Out）的有序列表
	# 栈是限制 线性表中，元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。
	# 允许 插入和删除 的一端，为变化的一端，称为 栈顶（Top）
	# 另一端为固定的一段，称为栈底（Bottom）
	
# 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶
	# 而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除
	
# 图解说明 出栈（pop）和 入栈（push）的概念:
```

![UTOOLS1575874225948.png](https://img04.sogoucdn.com/app/a/100520146/2194eebff7c351b0b4d4c1a1f4b19e0f)

### 栈的应用场景

```shell
# 子程序的调用:
	# 在跳往子程序前，会先将下个指令的地址存到栈中
	# 直到子程序执行完后再将地址取出，以回到原来的程序中
	
# 处理递归调用:
	# 和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入栈中
	
# 表达式的转换（中缀表达式转后缀表达式）和求值（实际解决）

# 二叉树的遍历

# 图形的深度优先（depth - first）搜索法
```

### 栈的快速入门

```shell
# 用数组模拟栈的使用
```

#### 思路分析

```shell
# 使用数组来模拟栈

# 定义一个 top 来表示栈顶，初始化为 -1

# 入栈的操作，当有数据加入到栈时，top++; stack[top] = data;

# 出栈的操作，int value = stack(top); top--; return value; 
```

#### 示意图

![UTOOLS1575874595743.png](https://img04.sogoucdn.com/app/a/100520146/d31c5dfd37d93ac6b61d6c1721076ad0)

#### 代码实现

```java
public class ArrayStack {

    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public void push(int val) {
        if (isFull()) throw new RuntimeException("the stack is full");
        top++;
        stack[top] = val;
    }

    public int pop() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        int val = stack[top];
        top--;
        return val;
    }

    public void show() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }

}
```

### 栈实现综合计算器（中缀表达式）

#### 思路分析

```shell
# 通过一个 index 值（索引），来遍历我们的表达式

# 如果我们发现是一个数字，就直接入数栈

# 如果发现扫描到是一个符号，就分如下情况:
	# 如果发现当前的符号栈为空，就直接入栈
	# 如果符号栈有操作符，就进行比较
		# 如果当前的的操作符的优先级小于或者等于栈中的操作符
			# 就需要从数栈中 pop 出两个数，再从符号栈中 pop 出一个符号，进行运算
			# 将得到结果，入数栈，然后将当前的操作符入符号栈
		
		# 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
		
# 当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数和符号，并运行

# 最后在数栈只有一个数字，就是表达式的结果
```

#### 示意图

![UTOOLS1575875907763.png](https://img03.sogoucdn.com/app/a/100520146/acecaafbf55167a46a7b84d82fae413a)

#### 代码实例

```java
public class Calculator {

    public static void main(String[] args) {

        String expression = "7*2*2-5+1-5+3-4";
        ArrayStack num = new ArrayStack(10);
        ArrayStack ope = new ArrayStack(10);

        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch;
        String keepNum = "";

        while (true) {
            ch = expression.substring(index, index + 1).charAt(0);
            if (ope.isOperator(ch)) {
                if (!ope.isEmpty()) {
                    if (ope.priority(ch) <= ope.priority(ope.peek())) {
                        num1 = num.pop();
                        num2 = num.pop();
                        oper = ope.pop();
                        res = num.cal(num1, num2, oper);
                        num.push(res);
                        ope.push(ch);
                    } else {
                        ope.push(ch);
                    }
                } else {
                    ope.push(ch);
                }
            } else {
                keepNum += ch;
                if (index == expression.length() - 1) {
                    num.push(Integer.parseInt(keepNum));
                } else {
                    if (ope.isOperator(expression.substring(index + 1, index + 2).charAt(0))) {
                        num.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                }
            }

            index++;
            if (index >= expression.length()) break;
        }

        while (true) {
            if (ope.isEmpty()) break;
            num1 = num.pop();
            num2 = num.pop();
            oper = ope.pop();
            res = num.cal(num1, num2, oper);
            num.push(res);
        }

        int result = num.pop();
        System.out.printf("表达式: %s = %d", expression, result);
    }

}

class ArrayStack {

    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public int peek() {
        return stack[top];
    }

    public void push(int val) {
        if (isFull()) throw new RuntimeException("the stack is full");
        top++;
        stack[top] = val;
    }

    public int pop() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        int val = stack[top];
        top--;
        return val;
    }

    public void show() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }

    public int priority(int operator) {
        if (operator == '*' || operator == '/') return 1;
        else if (operator == '+' || operator == '-') return 0;
        else return -1;
    }

    public boolean isOperator(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    public int cal(int num1, int num2, int operator) {
        int res = 0;

        switch (operator) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }

}
```

### 逆波兰计算器

```shell
# 输入一个逆波兰表达式（后缀表达式），使用栈（Stack）计算其结果

# 例如: (3+4)x5-6 对应的后缀表达式就是 3 4 + 5 x 6 -

# 思路分析:
	# 从左至由扫描，将 3 和 4 压入堆栈
	# 遇到 + 运算符，因此弹出 4 和 3，计算得 7 再入栈
	# 将 5 入栈
	# 接下来是 x 运算法，弹出 5 和 7，计算得 35 入栈
	# 将 6 入栈
	# 最后是 - 运算符，弹出 35 和 6，计算得 29，即最终结果
```

#### 代码实例

```java
public class PolandNotation {

    public static void main(String[] args) {
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";

        List<String> list = getListString(suffixExpression);
        System.out.println("rpnList = " + list);
        int res = calculate(list);

        System.out.println("result = " + res);
    }

    private static int calculate(List<String> list) {
        Stack<String> stack = new Stack<>();
        list.forEach(s -> {
            if (s.matches("\\d+")) stack.push(s);
            else {
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                switch (s){
                    case "+":
                       res = num1 + num2;
                       break;
                    case "-":
                        res = num1 - num2;
                        break;
                    case "*":
                        res = num1 * num2;
                        break;
                    case "/":
                        res = num1 / num2;
                        break;
                    default:
                        throw new RuntimeException("运算符有误");
                }
                stack.push(res + "");
            }
        });
        return Integer.parseInt(stack.pop());
    }

    private static List<String> getListString(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        Arrays.stream(split).forEach(s -> list.add(s));
        return list;
    }
    
}
```

#### 完整的逆波兰计算器代码示例

```shell
# 这里代码太长了，略。有兴趣的可以自行 LeetCode 看看
```

## 递归

### 递归应用场景

```shell
# 例如: 迷宫问题（回溯）用到 递归（Recursion）
```

![UTOOLS1575943702672.png](https://img01.sogoucdn.com/app/a/100520146/28e82c9babd86cef983086fd03ec790d)

### 递归的概念

```shell
# 递归就是方法自己调用自己

# 每次调用时传入不同的变量

# 递归有助于编程者用简洁的代码解决复杂的问题
```

### 递归调用机制

![UTOOLS1575943845235.png](https://img01.sogoucdn.com/app/a/100520146/701068c6cfd6aa60ae83e6ffc982b0ea)

### 递归能解决什么样的问题

```shell
# 各种数学问题:
	# 8 皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子的问题...
	
# 各种算法中也使用到了递归:
	# 快排、归并排序、二分查找、分治算法...
	
# 将用栈解决的问题 -> 变成递归代码比较简洁
```

### 递归需要遵守的重要规则

```shell
# 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）

# 方法的局部变量是独立的，不会互相影响，比如 n 变量

# 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据

# 递归必须向 退出递归的条件 逼近，否则就是无限递归，出现 StackOverflowError

# 当一个方法执行完毕，或者遇到 return，就会返回
	# 遵守谁调用，就将结果返回给谁
	# 同时当方法执行完毕或者返回时，该方法也就执行完毕
```

### 迷宫问题

#### 示例图

![UTOOLS1575945659858.png](https://img01.sogoucdn.com/app/a/100520146/e7e8ded6e23aa34ceaabfc1afcfa15b7)

#### 代码示例

```java
public class MiGong {

    public static void main(String[] args) {
        // 二维数组，模拟迷宫地图
        int[][] map = new int[8][7];
        // 使用 1 表示墙，上下左右全部置为 1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }

        // 设置挡板
        map[3][1] = 1;
        map[3][2] = 1;
        map[1][2] = 1;
        map[2][2] = 1;

        System.out.println("地图情况 --- ");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }

        setWay(map, 2, 4);

        System.out.println("小球走过，并标识过的地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }


    }

    /**
     * 走迷宫
     * 0: 没有走过 | 1: 表示墙 | 2: 表示通路可以走 | 3: 表示该点已经走过，但是走不通
     * 策略: 下 -> 右 -> 上 -> 左
     * @param map : 地图
     * @param i : 从哪个位置开始找（横坐标）
     * @param j : 从哪个位置开始找（纵坐标）
     * @return  : 找到路就返回 true，否则 false
     */
    private static boolean setWay(int[][] map, int i, int j) {

        if (map[6][5] == 2) return true;
        else {
            if (map[i][j] == 0) { // 如果该点还没有走过
                map[i][j] = 2; // 假设该点可以走通
                if (setWay(map, i+1, j)) return true;
                else if (setWay(map, i,j+1)) return true;
                else if (setWay(map, i-1, j)) return true;
                else if (setWay(map, i, j-1)) return true;
                else {
                    map[i][j] = 3;
                    return false;
                }
            } else {    // 如果 map[i][j] != 0 ，可能是 1,2,3
                return false;
            }
        }
    }

}
```

### 八皇后问题

#### 八皇后问题介绍

```shell
# 八皇后问题: 回溯算法的典型案例
	# 在 8 X 8 格的国际象棋上拜访 8 个皇后，使其不能互相攻击
	# 即: 任意两个皇后都不能处于同一行、同一列、同一斜线上，问有多少种摆法
```

#### 思路分析

```shell
# 第一个皇后先放第一行第一列

# 第二个皇后放在第二行第一列、然后判断是否 OK，如果不 OK，继续放在第二列、第三列、依次类推，直到合适

# 继续第三个皇后、还是第一列、第二列... 直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正解

# 当得到一个正解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到

# 然后回头继续第一个皇后放第二列，后面循序执行上述步骤
```

#### 说明

```shell
# 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法
	# 用一个一维数组即可解决问题: arr[8] = {0, 4, 7, 5, 2, 6, 1, 3}
	# 对应 arr 下标，表示第几行，即第几个皇后
	# arr[i] = val，val 表示第 i+1 个皇后，放在第 i+1 行的第 var + 1 列
```

#### 代码实例

```java
public class Queue8 {

    // 八皇后
    int max = 8;
    // 皇后放置位置的结果，例: arr = {0, 4, 7, 5, 2, 6, 1, 3}
    int[] array = new int[max];

    static int count = 0;
    static int judgeCount = 0;

    public static void main(String[] args) {
        Queue8 queue8 = new Queue8();
        queue8.check(0);
        System.out.printf("一共有 %d 种解法", count);
        System.out.printf("一共判断冲突的次数 %d 次", judgeCount);
    }

    /**
     * 递归放置皇后
     * @param n : 第 n 个皇后
     */
    private void check(int n) {
        // 判断是否第 8 个皇后
        if(n == max) {
            print();
            return;
        }

        // 依次放入皇后，并判断是否冲突
        for (int i = 0; i < max; i++) {
            // 先把当前皇后 n 放入该行的第一列
            array[n] = i;
            // 判断当放置第 n 个皇后到 i 列时，是否冲突
            // 如果不冲突，接着放第 n+1 个皇后
            if (judge(n)) check(n + 1);
        }
    }

    /**
     * 当放置第 n 个皇后，检测该皇后是否和前面已经摆放的皇后冲突
     * @param n : 第 n 个皇后
     * @return : 冲突返回 false，否则 true
     * 说明:
     *  array[i] == array[n] : 判断当前第 n 个皇后是否和前一个 n-1 皇后在同一列
     *  Math.abs(n - i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 个皇后在同一斜线上
     */
    private boolean judge(int n) {
        judgeCount++;
        for (int i = 0; i < n; i++) {
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) return false;
        }
        return true;
    }

    /**
     * 输出皇后摆放的位置
     */
    private void print(){
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }

}
```

## 排序算法

### 排序算法的介绍

```shell
# Sort Algorithm :
	# 将一组数据，依指定的顺序进行排列的过程。
```

### 排序的分类

```shell
# 内部排序:
	# 指将需要处理的所有数据都加载到 内存 中进行排序。
	
# 外部排序:
	# 数据量过大，无法全部加载到内存中，需要借助 外部存储文件 进行排序。
	
# 常见的排序算法分类图示:
```

![UTOOLS1575957042259.png](https://img03.sogoucdn.com/app/a/100520146/ddd304ad218050cc0eee373f9747c83b)

### 算法的时间复杂度

#### 度量一个程序（算法）执行时间的两种方法

```shell
# 事后统计:
	# 方法可行，但是有两个问题:
		# 1. 需要实际运行程序
		# 2. 需要在同台计算机相同状态运行不同算法，才能比较哪个算法更快

# 事前估算:
	# 通过分析某个算法的 时间复杂度 来判断哪个算法更优
```

#### 时间频度

##### 基本介绍

```shell
# 时间频度:
	# 一个算法花费的时间与算法中语句的执行次数成正比
	# 所以一个算法中的语句执行次数，被称为 语句频度 或 时间频度
	# 记为 T(n)
```

##### 举例说明 - 基本案例

```java

int total = 0;
int end = 100;

// 时间频度 T(n) = n + 1;
for (int i = 1; i <= end; i++) {
  total += i;
}

// 时间频度 T(n) = 1;
total = (1+end) * end / 2;
```

##### 举例说明 - 忽略常数项

![UTOOLS1575958089977.png](https://img01.sogoucdn.com/app/a/100520146/90774205911d04a808d2968113f91e0b)

```shell
# 结论:
	# 2n+20 和 2n 随着 n 变大，执行曲线无限接近，20 可以忽略。
	# 3n+10 和 3n 随着 n 变大，执行曲线无限接近，10 可以忽略
```

##### 举例说明 - 忽略低次项

![UTOOLS1575958276261.png](https://img03.sogoucdn.com/app/a/100520146/5ad314eabbf8e189f0ea9d612c12ac3f)

```shell
# 结论:
	# 2n^2+3n+10 和 2n^2 随着 n 变大，执行曲线无限接近，可以忽略 3n+10
	# n^2+5n+20 和 n^2 随着 n 变大，执行曲线无限接近，可以忽略 5n+20
```

##### 举例说明 - 忽略系数

![UTOOLS1575958474356.png](https://img04.sogoucdn.com/app/a/100520146/884fae2d38c3b2d1563a092655f8965b)

```shell
# 结论:
	# 随着 n 值变大，5n^2+7n 和 3n^2+2n，执行曲线重合，说明该情况下， 5 和 3 可以忽略
	# 而 n^3+5n 和 6n^3+4n，执行曲线分离，说明 多少次方 是关键
```

### 时间复杂度

```shell
# 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n) 表示

# 若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数
	# 则称 f(n) 是 T(n) 的同数量级函数
	# 记作 T(n) = O（f(n)）
	# 为算法的渐进事件复杂度，简称事件复杂度
	
# T(n) 不同，但时间复杂度可能相同。
	# 例: T(n)=n²+7n+6 与 T(n)=3n²+2n+2 
		# 它们的 T(n) 不同，但时间复杂度相同，都为 O(n²)
		
# 计算时间复杂度的方法:
	# 用常数 1 代替运行时间中的所有加法常数:
		# T(n)=n²+7n+6 	=>  T(n)=n²+7n+1
		
	# 修改后的运行次数函数中，只保留最高阶项:
		# T(n)=n²+7n+1  =>  T(n)=n²
		
	# 去除最高阶项的系数:
		# T(n)=3n²  =>  T(n)=n²  =>  O(n²)
```

#### 常见的时间复杂度

```shell
# 常数阶 : O(1)

# 对数阶 : O(log2n)

# 线性阶 : O(n)

# 线性对数阶 : O(nlog2n)

# 平方阶 : O(n^2)

# 立方阶 : O(n^3)

# k 次方阶 : O(n^k)

# 指数阶 : O(2^n)
```

##### 常见的时间复杂度图解

![UTOOLS1575961919454.png](https://img01.sogoucdn.com/app/a/100520146/622dd61edb222afe56e58864cbc68b3b)

##### 说明

```shell
# 常见的算法时间复杂度由小到大依次为:
	# O(1) < O(log2n) < O(n) < O(nlog2n) < 0(n^2) < O(n^3) < O(n^k) < O(2^n)
	# 随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低
	
# 从图中可见，我们应该尽可能避免使用指数阶的算法
```

##### 常数阶 O(1)

```shell
# 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)
```

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

##### 对数阶 O(log2n)

```java
int i = 1;
while (i < n) {
  i = i * 2;
}
```

```shell
# 在 while 循环里面，每次都将 i * 2，距离 n 就越来越近了
	# 假设循环 x 次后，i >= 2，此时循环退出
  # 即: 2^x >= n ，那么 x = log2(n) < 2是底数，n是真数 >
  # 即: 代码循环 x 次结束，因此时间复杂度为 O(log2(n)) < i = i * 2，所以底数为 2 >
```

##### 线性阶 O(n)

```java
for (int i = 1; i <= n; ++i) {
  j = i;
  j++;
}
```

```shell
# for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的
	# 因此这类代码都可以用 O(n) 来表示它的复杂度
```

##### 线性对数阶 O(nlogN)

```java
for (int i = 1; i < n; i++) {
  i = 1;
  while (i < n){
    i + i * 2;
  }
}
```

```shell
# 线性对数阶 O(nlogN):
	# 将时间复杂度为 O(logN) 的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)
```

##### 平方阶 O(n²)

```java
for (int x = 1; i <= n; x++) {
  for (int i = 1; i <= n; i++) {
    j = i;
    j++;
  }
}
```

```shell
# 平方阶 O(n²):
	# 将 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)
	# 即 O(n²) 如果将其中一层循环的 n 改成 m，那它的时间复杂度就变成了 O(m * n)
	
# O(n³)、O(n^k) 参照理解就好
```

#### 平均时间复杂度和最坏时间复杂度

```shell
# 平均时间复杂度:
	# 指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
	
# 最坏时间复杂度:
	# 一般讨论的时间复杂度均是最坏情况下的时间复杂度。
	# 这样做的原因是:
		# 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限
		# 这就保证了算法的运行时间不会比最坏情况更长
		
# 平均时间复杂度和最坏时间复杂度是否一致，和算法有关，如下图示:
```

![UTOOLS1575965582212.png](https://img02.sogoucdn.com/app/a/100520146/c565305a4c2788ed43da30d01f467c8e)

### 算法的空间复杂度简介

#### 基本介绍

```shell
# 类似于时间复杂度，一个算法的空间复杂度定义为该算法所消耗的存储空间，它也是问题规模 n 的函数。

# 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。
	# 有的算法需要占用的临时工作单元数与解决问题的规模 n 有关
	# 它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元
	# 例: 快速排序、归并排序算法、基数排序...
	
# 在做算法分析时，主要讨论的是时间复杂度。
	# 从用户使用体验上看，更看重的程序执行的速度。
	# 一些缓存产品(redis, memcache) 和算法(基数排序) 本质就是用空间换空间
```

### 冒泡排序

#### 基本介绍

```shell
# 冒泡排序的基本思想:
	# 通过对待排序序列从前向后（从下标较小的元素开始）->
		# 依次比较相邻元素的值，若发现逆序则交换 ->
		# 使值较大的元素逐渐从前移向后部 ->
		# 就像水底下的气泡一样逐渐向上冒
		
# 优化:
	# 排序过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序。
	# 因此，在排序过程中设置一个 flag 判断元素是否进行过交换，从而减少不必要的比较。
```

#### 图解冒泡过程

![UTOOLS1576028581654.png](https://img04.sogoucdn.com/app/a/100520146/d66c66ef37c17b9a9df6caeb8f46e017)

##### 小结图解

```shell
# 一共进行 数组的大小 - 1 次大的循环

# 每一趟排序的次数在逐渐的减少

# 如果发现某趟排序中，没有发生一次交换，就提前结束冒泡排序，达到优化目的
```

#### 代码示例

```java
public class BubbleSort {

    public static void main(String[] args) {
        // 测试冒泡排序的速度 O(n²)
        int[] arr = new int[80000];

        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        System.out.println("排序前时间: " + DateUtil.now());

        bubbleSort(arr);

        System.out.println("排序后时间: " + DateUtil.now());
        System.out.println("排序后数组: " + Arrays.toString(arr));
    }

    private static void bubbleSort(int[] arr) {

        boolean flag = false;
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if(arr[j] > arr[j+1]) {
                    flag = true;
                    arr[j] ^= arr[j+1];
                    arr[j+1] ^= arr[j];
                    arr[j] ^= arr[j+1];
                }
            }
            if (!flag) break;
            else flag = false;
        }

    }

}
```

### 选择排序

#### 基本介绍

```shell
# 选择式排序也属于内部排序法。
	# 是从预排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。
```

#### 选择排序思想

```shell
# 基本思想:
	# 第一次从 arr[0] - arr[n-1] 中选取最小值，与 arr[0] 交换
	# 第二次从 arr[1] - arr[n-1] 中选取最小值，与 arr[1] 交换
	# ...
	# 第 i 次从 arr[i-1] - arr[n-1] 中选取最小值，与 arr[i-1] 交换
	# 第 n-1 次从 arr[n-2] - arr[n-1] 中选取最小值，与 arr[n-2] 交换
	# 总共通过 n-1 次，得到一个按排序码从小到大排序的有序序列
```

#### 思路分析图解

![UTOOLS1576030240965.png](https://img02.sogoucdn.com/app/a/100520146/809e89494b8fbd6a8374b715cb3bdde3)

##### 小结图解

```shell
# 假设原始的数组: 101, 34, 119, 1
	# 第一轮排序: 1, 34, 119, 101
	# 第二轮排序: 1, 34, 119, 101
	# 第三轮排序: 1, 34, 101, 119
	
# 选择排序一共有 数组大小 - 1 轮排序
	# 每一轮排序，又是一个循环
		# 先假定当前数是最小数，然后和后面的每个数进行比较，发现更小的，就交换

# 冒泡是每轮排序确定最大值，选择排序是每轮排序确定最小值，本质是一样的
```

#### 代码实例

```java
public class SelectSort {

    public static void main(String[] args) {
        // 选择排序的时间复杂度 O(n²)
        int[] arr = new int[80000];

        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        System.out.println("排序前时间: " + DateUtil.now());

        selectSort(arr);

        System.out.println("排序后时间: " + DateUtil.now());
        System.out.println("排序后数组: " + Arrays.toString(arr));
    }

    private static void selectSort(int[] arr) {

        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            int min = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                if(min > arr[j]) {
                   min = arr[j];
                   minIndex = j;
                }
            }
            if (minIndex != i){
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
        }

    }

}
```

### 插入排序

#### 基本介绍

```shell
# 插入式排序也属于内部排序法
	# 是对于 预排序的元素以插入的方式寻找该元素的适当位置，以达到排序的目的
```

#### 插入排序法思想

```shell
# 基本思想:
	# 把 n 个待排序的元素看成一个有序表和一个无序表
	# 开始时，有序表中只包含一个元素，无序表中包含有 n-1 个元素
	# 排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较
	# 把它插入到有序表中的适当位置，使之成为新的有序表。
```

#### 思路图解

![UTOOLS1576031534991.png](https://img02.sogoucdn.com/app/a/100520146/026bab54aaa109510d277de5c28f5344)

##### 代码实现

```java
public class InsertSort {

    public static void main(String[] args) {
        // 插入排序的时间复杂度 O(n²)
        int[] arr = new int[80000];

        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        System.out.println("排序前时间: " + DateUtil.now());

        insertSort(arr);

        System.out.println("排序后时间: " + DateUtil.now());
        System.out.println("排序后数组: " + Arrays.toString(arr));
    }

    private static void insertSort(int[] arr) {

        int insertVal = 0;
        int insertIndex = 0;
        for (int i = 1; i < arr.length; i++) {
            insertVal = arr[i];
            insertIndex = i - 1;

            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }

            if (insertIndex + 1 != i) arr[insertIndex + 1] = insertVal;
        }

    }

}
```

### 希尔排序

#### 简单插入排序存在的问题

``` shell
# 例: 数组 arr = {2, 3, 4, 5, 6, 1}，这时需要插入的数 1(最小)

# 过程图:
```

![UTOOLS1576032473912.png](https://img03.sogoucdn.com/app/a/100520146/5e5e8021bb7fb08c00e71da5a3fa5c33)

```shell
# 结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响
```

#### 希尔排序介绍

```shell
# 希尔排序也是一种 插入排序。
	# 它是简单插入排序经过改进之后的版本，也称为缩小增量排序。
```

#### 希尔排序基本思想

```shell
# 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序
	# 随着增量逐渐减少，每组包含的关键词越来越多
	# 当增量减至1时，整个文件恰被分成一组，算法便终止
```

#### 希尔排序示意图

![UTOOLS1576033151630.png](https://img04.sogoucdn.com/app/a/100520146/745265f1d32f7981690893ad307d89ad)

![UTOOLS1576033167039.png](https://img04.sogoucdn.com/app/a/100520146/b5e531e1555270f5421cd66f07530b38)

#### 代码示例

```java
public class ShellSort {

    public static void main(String[] args) {
        // 希尔排序的时间复杂度 O(n * logN)
        int[] arr = new int[80000];

        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        System.out.println("排序前时间: " + DateUtil.now());

        shellSort(arr);

        System.out.println("排序后时间: " + DateUtil.now());
        System.out.println("排序后数组: " + Arrays.toString(arr));
    }

    private static void shellSort(int[] arr) {

        // 增量 gap，并逐步缩小增量
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            // 从第 gap 个元素，逐个对其所在的组进行直接插入排序
            for(int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];
                if (arr[j] < arr[j - gap]) {
                    while (j - gap >= 0 && temp < arr[j - gap]) {
                        arr[j] = arr[j-gap];
                        j -= gap;
                    }
                    arr[j] = temp;
                }
            }
        }

    }

}
```

### 快速排序

#### 快速排序法介绍

```shell
# 快速排序是对 冒泡排序 的一种改进。

# 基本思想:
	# 通过一趟排序将要排序的数据分割成独立的两部分 ->
		# 其中一部分的所有数据都比另外一部分的所有数据都要小 ->
		# 按此方法对这两部分数据分别进行快速排序 ->
		# 整个排序过程可以递归进行 ->
		# 以此达到整个数据变成有序序列
```

#### 快速排序示意图

![UTOOLS1576034485095.png](https://img03.sogoucdn.com/app/a/100520146/1bea727fbd818c628c88c353d7f173ef)

#### 代码实现

```java
public class QuickSort {

    public static void main(String[] args) {
        // 快速排序的时间复杂度 O(n * logN)
        int[] arr = new int[80000];

        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        System.out.println("排序前时间: " + DateUtil.now());

        quickSort(arr, 0, arr.length - 1);

        System.out.println("排序后时间: " + DateUtil.now());
        System.out.println("排序后数组: " + Arrays.toString(arr));
    }

    /**
     * 快速排序
     * @param arr : 数组
     * @param left  : 左下标
     * @param right : 右下标
     */
    private static void quickSort(int[] arr, int left, int right) {

        int l = left;
        int r = right;
        int pivot = arr[(left + right) / 2];    // 中轴值
        int temp = 0;
        // while 循环: 将比 pivot 值小的放到左边，反之放到右边
        while (l < r) {
            // 在 pivot 左边一直找，找到大于等于 pivot 值，才退出
            while(arr[l] < pivot) {
                l += 1;
            }
            // 在 pivot 右边一直找，找到小于等于 pivot 值，才退出
            while(arr[r] > pivot) {
                r -= 1;
            }
            // 如果 l >= r: 说明 pivot 的左边值全小于等于 pivot，反之大于等于 pivot
            if( l >= r) break;

            // 交换值
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            // 如果交换完，发现下标值 == pivot 值，则下标移动
            if (arr[l] == pivot) r -= 1;
            if (arr[r] == pivot) l += 1;
        }
        // 如果两下标相等，必须移动两者下标，否则栈溢出
        if (l == r) {
            l += 1;
            r -= 1;
        }

        // 左递归
        if (left < r) quickSort(arr, left, r);
        // 右递归
        if (right > l) quickSort(arr, l, right);
    }

}
```

### 归并排序

#### 归并排序介绍

```shell
# 归并排序:
	# 算法采用经典的分治策略:
		# 将问题 分 成一些小问题然后递归求解
		# 将 分 的各阶段答案合并在一起，就是 治
```

#### 归并排序图解

![UTOOLS1576041601409.png](https://img02.sogoucdn.com/app/a/100520146/0afb35a01d8b6d051c4fa09e946887ff)

![UTOOLS1576041651579.png](https://img01.sogoucdn.com/app/a/100520146/9bd9d8d0d2e718a59b4d1bb9f4676440)

#### 代码示例

```java
public class MergeSort {

    public static void main(String[] args) {
        // 归并排序的时间复杂度 O(n * logN)
        int[] arr = new int[80000];

        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        System.out.println("排序前时间: " + DateUtil.now());

        int temp[] = new int[arr.length];
        mergeSort(arr, 0, arr.length - 1, temp);

        System.out.println("排序后时间: " + DateUtil.now());
        System.out.println("排序后数组: " + Arrays.toString(arr));
    }

    private static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid, temp);
            mergeSort(arr, mid + 1, right, temp);
            merge(arr, left, mid, right, temp);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;
        int j = mid + 1;
        int t = 0;

        while(i <= mid && j <= right) {
            if(arr[i] <= arr[j]) {
                temp[t] = arr[i];
                t += 1;
                i += 1;
            } else {
                temp[t] = arr[j];
                t += 1;
                j += 1;
            }
        }

        while (i <= mid) {
            temp[t] = arr[i];
            t += 1;
            i += 1;
        }

        while (j <= right) {
            temp[t] = arr[j];
            t += 1;
            j += 1;
        }

        t = 0;
        int tempLeft = left;
        while (tempLeft <= right) {
            arr[tempLeft] = temp[t];
            t += 1;
            tempLeft += 1;
        }
    }

}
```

### 基数排序

#### 基数排序介绍

```shell
# 基数排序:
	# 属于 "分配式排序"，又称 "桶子法"
	# 顾名思义，是通过键值的各个位的值，将要排序的元素分配至某些 "桶" 中，达到排序的作用
	# 基数排序法 是效率高的稳定性排序法
	# 基数排序是桶排序的扩展
```

#### 基本思想

```shell
# 将所有待比较数值统一为同样的数位长度，数位较短的数前面补 0
	# 然后从最低位开始，依次进行一次排序
	# 这样从最低位排序一直到最高位排序完成后，数列就变成一个有序序列
```

![UTOOLS1576043024195.png](https://img02.sogoucdn.com/app/a/100520146/9355670df7713f903b4c0e74679ea8cb)

![UTOOLS1576043057856.png](https://img02.sogoucdn.com/app/a/100520146/d13d8ddec29d039e0e297100819fe6ca)

#### 代码示例

```java
public class RadixSort {

    public static void main(String[] args) {
        // 基数排序的时间复杂度 O(n * logN)
        int[] arr = new int[80000];

        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        System.out.println("排序前时间: " + DateUtil.now());


        radixSort(arr);

        System.out.println("排序后时间: " + DateUtil.now());
        System.out.println("排序后数组: " + Arrays.toString(arr));
    }

    private static void radixSort(int[] arr) {
      int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) max = arr[i];
        }
        int maxLength = (max + "").length();
        int[][] bucket = new int[10][arr.length];
        int[] bucketElementCounts = new int[10];

        for (int i = 0, n =1; i < maxLength ; i++, n *= 10) {
            for (int j = 0; j < arr.length; j++) {
                int digitOfElement = arr[j] / n % 10;
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            int index = 0;
            for (int k = 0; k < bucketElementCounts.length; k++) {
                if (bucketElementCounts[k] != 0) {
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        arr[index++] = bucket[k][l];
                    }
                }
                bucketElementCounts[k] = 0;
            }
        }
    }

}
```

#### 基数排序的说明

```shell
# 基数排序是对传统桶排序的扩展，速度很快，稳定

# 基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成 OOM

# 目前的基数排序是不支持负数的。
```

### 常用排序算法总结和对比

#### 一张排序算符的比较图

![UTOOLS1576043674525.png](https://img03.sogoucdn.com/app/a/100520146/c3398df073a18d58d272f214223ececc)

#### 相关术语解释

```shell
# 稳定:
	# 例: a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面
	
# 不稳定:
	# 例: a 原本在 b 前面，而 a=b，排序之后 a 可能出现在 b 的后面
	
# 内排序:
	# 所有排序操作都在内存中完成
	
# 外排序:
	# 由于数据太大，因此将数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
	
# 时间复杂度:
	# 运行完一个程序所需内存的大小
	
# 空间复杂度:
	# 运行完一个程序所需内存的大小
	
# n:
	# 数据规模
		
# k:
	# 桶的个数
	
# In-place:
	# 不占用额外内存
	
# Out-place:
	# 占用额外内存
```

## 查找算法

### 查找算法介绍

```shell
# 在 Java 中，常用的查找有四种:
	# 顺序(线性)查找
	
	# 二分查找/折半查找
	
	# 插值查找
	
	# 斐波那契查找
```

### 线性查找算法

#### 代码实现

```java
public class SeqSearch {

    public static void main(String[] args) {
        int arr[] = {1, 9, 11, -1, 34, 89};
        int index = seqSearch(arr, -1);
        if (index == -1) System.out.println("the val was not found");
        else System.out.println("the index of this val is : " + index);
    }

    private static int seqSearch(int[] arr, int val) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == val) return i;
        }
        return -1;
    }

}
```

### 二分查找算法

#### 思路分析

![UTOOLS1576044449348.png](https://img02.sogoucdn.com/app/a/100520146/965254d9830767721e2c6963869e96ed)

#### 代码示例

```java
// 二分查找算法的前提是: 该数组是有序的
public class BinarySearch {

    public static void main(String[] args) {
        int arr[] = {1, 8, 10, 89, 1000, 1000, 1234};

        List<Integer> resIndexList = binarySearch(arr, 0, arr.length - 1, 1000);
        System.out.println("resIndexList = " + resIndexList);

    }

    private static List<Integer> binarySearch(int[] arr, int left, int right, int val) {
        if (left > right) return new ArrayList<>();

        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if (val > midVal) return binarySearch(arr, mid + 1, right, val);
        else if (val < midVal) return binarySearch(arr, left, mid - 1, val);
        else {
            List<Integer> resIndexList = new ArrayList<>();
            int temp = mid - 1;
            while (true) {
                if (temp < 0 || arr[temp] != val) break;
                resIndexList.add(temp);
                temp -= 1;
            }
            resIndexList.add(mid);

            temp = mid + 1;
            while (true) {
                if (temp > arr.length - 1 || arr[temp] != val) break;
                resIndexList.add(temp);
                temp += 1;
            }
            return resIndexList;
        }
    }

}
```

### 插值查找算法

#### 原理介绍

```shell
# 原理介绍:
	# 插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。
	
# 将二分查找中的求 mid 索引的公式做以修改:
	# low : 表示左边索引 left
	# high : 表示右边索引 right
	# key : 要查找的值
```

![UTOOLS1576045405552.png](https://img02.sogoucdn.com/app/a/100520146/0022a020e8f1c2295f1fa0a519036ab5)

```shell
# 插值索引:
	# int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);
	
# 对应前面的代码公式
	# int mid = left + (right - left) * (val - arr[left]) / (arr[right] - arr[left])
```

#### 举例说明插值查找算法

![UTOOLS1576045572988.png](https://img01.sogoucdn.com/app/a/100520146/25a6bf9fafc0e4f076c57d92e8292972)

#### 代码示例

```java
public class InsertValueSearch {

    public static void main(String[] args) {
        int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };

        int index = insertValueSearch(arr, 0, arr.length - 1, 1234);

        System.out.println("index : " + index);
    }

    private static int insertValueSearch(int[] arr, int left, int right, int val) {
        if (left > right || val < arr[0] || val > arr[arr.length - 1]) return - 1;

        int mid = left + (right - left) * (val - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (val > midVal) return insertValueSearch(arr, mid + 1, right, val);
        else if (val < midVal) return insertValueSearch(arr, left, mid - 1, val);
        else return mid;
    }

}
```

#### 注意事项

```shell
# 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快

# 关键字分布不均匀的情况下，该方法不一定比二分查找好
```

### 裴波那契查找算法

#### 基本介绍

```shell
# 裴波那契（黄金分割法）:
	# 利用黄金分割点 0.618
	
# 裴波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}
	# 发现裴波那契数列的两个相邻数的比例，无限接近 黄金分割值 0.618
```

#### 裴波那契原理

```shell
# 裴波那契查找原理与前两种相似，仅仅改变了中间节点（mid）的位置
	# mid 不再是中间或插值得到，而是位于黄金分割点附近
	# 即: mid = low + F(k-1) - 1 （F 代表裴波那契数列）

# 如下图所示:
```

![UTOOLS1576047272772.png](https://img01.sogoucdn.com/app/a/100520146/1f88e68d3eb838cd88ca0dc38573956d)

##### 对 F(k-1) - 1 的理解

```shell
# 由裴波那契数列 F[k] = F[k-1] + F[k-2] 的性质，可以得到:
	# (F[k] - 1) = (F[k-1] - 1) + (F[k-2] - 1) + 1
	
# 该式说明:
	# 只要顺序表的长度为 F[k] - 1，则可以将该表分成长度为 F[k-1] - 1 和 F[k-2] - 1 的两段
	# 如上图所示
	# 从而中间位置为 mid = low + F(k-1) - 1
	
# 类似的，每一子段也可以用相同的方式分割
	
# 但顺序表长度 n 不一定刚好等于 F[k] - 1，所以需要将原来的顺序表长度 n 增加至 F[k] - 1
	# 这里的 k 值只要能使得 F[k] - 1 恰好大于或等于 n 即可
	# 由以下代码可得，顺序表长度增加后，新增的位置（从 n+1 到 F[k] - 1 位置），都赋为 n 位置的值即可
while(n > fib(k) -1)
	k++;
```

#### 代码示例

```java
public class FibonacciSearch {

    public static int maxSize = 20;

    public static void main(String[] args) {
        int[] arr = {1, 8, 10, 89, 1000, 1234};
        System.out.println("index = " + fibSearch(arr, 89));
    }

    private static int fibSearch(int[] arr, int val) {

        int low = 0;
        int high = arr.length - 1;
        int k = 0;
        int mid = 0;
        int f[] = fib();
        while(high > f[k] - 1) {
            k++;
        }

        int[] temp = Arrays.copyOf(arr, f[k]);
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = arr[high];
        }

        while (low <= high) {
            mid = low + f[k - 1] - 1;
            if (val < temp[mid]) {
                high = mid - 1;
                k--;
            } else if (val > temp[mid]) {
                low = mid + 1;
                k -= 2;
            } else {
                if (mid <= high) return mid;
                else return high;
            }
        }
        return -1;
    }

    private static int[] fib() {
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f;
    }

}
```

## 哈希表

### 哈希表的基本介绍

```shell
# 哈希表（散列表）:
	# 根据 关键码值 而直接进行访问的数据结构。
	# 也就是说，它通过把 关键码值 映射到 表 中一个位置来访问记录
	# 这个映射函数叫做散列函数
	# 存放记录的数组叫做散列表
```

```shell
# 本篇教程只有一个 HashTab 的代码案例，不太符合主流 HashMap 的应用，略...
```

## 树结构的基础部分

### 二叉树

#### 为什么需要树这种数据结构

```shell
# 数组存储方式的分析:
	# 优点:
		# 通过下标方式访问元素，速度快。
		# 对于有序数组，还可使用二分查找提高检索速度。
		
	# 缺点:
		# 如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率较低
		
# 操作示意图如下:
```

![UTOOLS1576048725879.png](https://img01.sogoucdn.com/app/a/100520146/561311089220b58b2acc25fe7a9e65a5)

```shell
# 链式存储方式的分析:
	# 优点: 在一定程度上对数组存储方式有优化
		# 例: 插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好
		
	# 缺点:
		# 在进行检索时，效率仍然较低
		
# 操作示意图如下:
```

![UTOOLS1576048843440.png](https://img01.sogoucdn.com/app/a/100520146/d22988626f4192a2f545236fdc2fc8cd)

```shell
# 树存储方式的分析:
	# 能提高数据存储，读取的效率，比如利用 二叉排序树
		# 既可以保证数据的检索速度，同时也可以保证数据的插入、删除、修改的速度
```

#### 树示意图

![UTOOLS1576048935839.png](https://img01.sogoucdn.com/app/a/100520146/bc51a685d4f24603ed00033e338908ef)

```shell
# 树的常用术语:
	# 节点
	# 根节点
	# 父节点
	# 子节点
	# 叶子节点（没有子节点的节点）
	# 节点的权（节点值）
	# 路径（从 root 节点找到该节点的路线）
	# 层
	# 子树
	# 树的高度（最大层数）
	# 森林（多颗子树构成森林）
```

#### 二叉树的概念

```shell
# 每个节点 最多只能有两个子节点 的树称为二叉树

# 二叉树的子节点分为 左节点 和 右节点

# 示意图:
```

![UTOOLS1576049150766.png](https://img04.sogoucdn.com/app/a/100520146/a4923a40771720d4f374eb37fb94367c)

```shell
# 如果该二叉树的所有 叶子节点 都在 最后一层
	# 并且节点总数 = 2^n - 1 （n 为层数）
	# 我们称之为 满二叉树
```

![UTOOLS1576049226879.png](https://img03.sogoucdn.com/app/a/100520146/37bea5a251af9a3499c6c81d4ab20806)

```shell
# 如果该二叉树的所有 叶子节点 都在 最后一层 或者 倒数第二层
	# 而且最后一层的叶子节点在左边连续
	# 倒数第二层的叶子节点在右边延续，我们称为 完全二叉树
```

![UTOOLS1576049297667.png](https://img02.sogoucdn.com/app/a/100520146/c589cefbd68606d120288a5d2ed4ea7a)

#### 二叉树遍历的说明

```shell
# 前序遍历:
	# 先输出父节点，再遍历 左子树 和 右子树
	
# 中序遍历:
	# 先遍历 左子树，再输出 父节点，再遍历 右子树
	
# 右序遍历:
	# 先遍历 左子树，再遍历 右子树，最后输出 父节点
	
# 小结:
	# 看父节点的输出顺序，就能确定是 前序、中序、还是后序
```

##### 代码实现

```java
public class BinaryTree {

    public Node root;

    public void preOrder() {
        if (root == null) throw new RuntimeException("the tree is empty");
        else root.preOrder();
    }

    public void infixOrder() {
        if (root == null) throw new RuntimeException("the tree is empty");
        else root.infixOrder();
    }
    public void postOrder() {
        if (root == null) throw new RuntimeException("the tree is empty");
        else root.postOrder();
    }

}

class Node {
    public int no;
    public Node left;
    public Node right;

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                '}';
    }

    // 前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) this.left.preOrder();
        if (this.right != null) this.right.preOrder();
    }

    // 中序遍历
    public void infixOrder() {
        if (this.left != null) this.left.preOrder();
        System.out.println(this);
        if (this.right != null) this.right.preOrder();
    }

    // 后序遍历
    public void postOrder() {
        if (this.left != null) this.left.preOrder();
        if (this.right != null) this.right.preOrder();
        System.out.println(this);
    }
}
```

#### 二叉树 - 查找指定节点

##### 思路分析

```shell
# 前序查找思路
	# 先判断当前节点的 no 是否等于要查找的 ->
		# 如果相等，返回当前节点 ->
		# 如果不等，判断当前节点的左子节点是否为空 ->
		# 如果不为空，则递归前序查找 ->
		# 如果左递归前序查找，找到节点，则返回 ->
		# 否则继续判断，当前的节点的右子节点是否为空 ->
		# 如果不空，则继续向右递归前序查找
		
# 中序遍历与后序遍历，只是区分在什么时候对访问到的节点做处理
```

##### 代码实现

```shell
# 只是将前面遍历到节点后，做 System.out.println 的操作改为返回节点
```

```shell
# 删除也是同样的逻辑
```

## 略过的章节

```shell
# 因个人水平较低，对以下章节暂无实际工作需求

# 略过的章节有:	
	# 顺序存储二叉树
	# 线索化二叉树
	
	# 堆排序
	# 赫夫曼树
	# 赫夫曼编码
	# 二叉排序树
	# 平衡二叉树
	
	# 二叉树与 B树
	# 2-3 树
	# B树、B+树、B* 树
	
	# 图基本介绍
	# 图的表示方式
	# 图的快速入门案例
	# 图的深度优先遍历介绍
	# 图的广度优先遍历
	# 广度优先算法的代码实现
	# 图的代码汇总
	# 图的深度优先 vs 广度优先
```

## 程序员常用 10 种算法

### 二分查找算法（非递归）代码实现

```shell
# 个人感觉还是 递归 香，略...
```

### 分治算法

#### 汉诺塔游戏的代码实现

```java
public class Hanoi {

    public static void main(String[] args) {
        hanoiTower(5, 'A', 'B', 'C');
    }

    private static void hanoiTower(int num, char a, char b, char c) {
        // 如果只有一个盘
        if (num == 1) System.out.println("第 1 个盘从 " + a + "->" + c);
        else {
            // 如果 n >= 2，总是可以看做两个盘
            // 最下面的那个盘，最上面的所有盘
            hanoiTower(num - 1, a, c, b);
            // 把最下面的盘 A -> C
            System.out.println("第 " + num + " 个盘从 " + a + "->" + c );
            // 把 B塔的所有盘从 B -> C, 移动过程中使用到 A 塔
            hanoiTower(num -1, b, a, c);
        }
    }

}
```

### 动态规划算法

#### 基本介绍

```shell
# 核心思想:
	# 将 大问题划分为小问题 进行解决，从而一步步获取最优解的处理算法
	
# 动态规划算法 与 分治算法 类似
	
# 与 分治算法 不同的是，适合于用 动态规划 求解的问题
	# 经分解得到 子问题往往不是互相独立的
	# 即 下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解
	
# 动态规划可以通过填表的方式来逐步推进，得到最优解
```

#### 动态规划算法最佳实践 - 背包问题

```shell
# 背包问题: 有一个背包，容量为 4 磅，现有如下物品:
```

![UTOOLS1576056399110.png](https://img02.sogoucdn.com/app/a/100520146/cddc3975c01f0faa7ffbe1fc17c7add1)

```shell
# 要求达到的目标为装入背包的总价值最大，并且重量不超出

# 要求装入的物品不能重复
```

##### 思路分析 和 图解

```shell
# 背包问题 主要是指一个给定容量的背包、若干具有一定价值和重量的物品
	# 如何选择物品放入背包使物品的价值最大。
	
# 其中又分 01背包（每个物品最多放一个） 和 完全背包（每种物品都有无限件可用）

# 每次遍历到的第 i 个物品，根据 w[i] 和 v[i] 来确定是否需要将该物品放入背包中
	# 即: 对于给定的 n 个物品，设 v[i]、w[i] 分别为第 i 个物品的价值和重量
	# C 为背包的重量。
	# 再令 v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值
```

![UTOOLS1576057127591.png](https://img04.sogoucdn.com/app/a/100520146/c84853a4ae54e905bf65e10330592105)

##### 代码实现

```java
public class KnapsackProblem {

    public static void main(String[] args) {
        // 物品重量
        int[] w = {1, 4, 3};
        // 物品价值
        int[] v = {1500, 3000, 2000};
        // 背包的容量
        int m = 4;
        // 物品的个数
        int n = v.length;

        // max[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值
        int[][] maxVal = new int[n + 1][m + 1];
        // 记录放入商品的情况
        int[][] path = new int[n + 1][m + 1];

        // 动态规划处理
        for (int i = 1; i < maxVal.length; i++) {
            for (int j = 1; j < maxVal[0].length; j++) {
                // 公式
                if (w[i - 1] > j) maxVal[i][j] = maxVal[i - 1][j];
                else {
                    if (maxVal[i - 1][j] < v[i - 1] + maxVal[i - 1][j - w[i - 1]]) {
                        maxVal[i][j] = v[i - 1] + maxVal[i - 1][j - w[i - 1]]; //把当前的情况记录到 path
                        path[i][j] = 1;
                    } else {
                        maxVal[i][j] = maxVal[i - 1][j];
                    }

                }
            }
        }

        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < maxVal[i].length; j++) {
                System.out.print(maxVal[i][j] + " ");
            }
            System.out.println();
        }

        int i = path.length - 1; 
        int j = path[0].length - 1; 
        while (i > 0 && j > 0) { 
            if (path[i][j] == 1) {
                System.out.printf("第%d 个商品放入到背包\n", i);
                j -= w[i - 1]; 
            }
            i--;
        }

    }

}
```

### KMP 算法

#### 应用场景 - 字符串匹配问题

```shell
# 就是本篇笔记最开始讲的问题
```

#### KMP 算法介绍

```shell
# KMP 是一个解决 模式串在文本串 中是否出现过，如果出现过，最早出现的位置的经典算法

# KMP 算法利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度
	# 每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间
```

#### 思路分析图解

![UTOOLS1576114190765.png](https://img03.sogoucdn.com/app/a/100520146/97bf3e18baf3e70eeba5c0bef8080d27)

![UTOOLS1576114211402.png](https://img02.sogoucdn.com/app/a/100520146/498bd08797517aa100b03b1680bcfbf9)

![UTOOLS1576114281387.png](https://img04.sogoucdn.com/app/a/100520146/ac2caddac154da5f0276aa003b95c6b4)

![UTOOLS1576114352438.png](https://img03.sogoucdn.com/app/a/100520146/7fa8bac5c4ec24b95527cfe20cf1a8c8)

![UTOOLS1576114384756.png](https://img03.sogoucdn.com/app/a/100520146/78382c5bea9e62ad92abb0a3e0ab27bc)

#### 代码实现

```java
public class KMPAlgorithm {

    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";

        int[] next = kmpNext("ABCDABD");
        System.out.println("next = " + Arrays.toString(next));

        int index = kmpSearch(str1, str2, next);
        System.out.println("index = " + index);
    }

    private static int kmpSearch(String str1, String str2, int[] next) {
        for (int i = 0, j = 0; i < str1.length(); i++) {
            while (j > 0 && str1.charAt(i) != str2.charAt(j)) {
                j = next[j-1];
            }
            if (str1.charAt(i) == str2.charAt(j)) j++;
            if (j == str2.length()) return i - j + 1;
        }
        return -1;
    }

    private static int[] kmpNext(String val) {
        int[] next = new int[val.length()];
        next[0] = 0;
        for (int i = 1, j = 0; i < val.length(); i++) {
            while (j > 0 && val.charAt(i) != val.charAt(j)) {
                j = next[j-1];
            }
            if (val.charAt(i) == val.charAt(j)) j++;
            next[i] = j;
        }
        return next;
    }

}
```

